[
  {
    "file": "app/services/appointment_scheduler.py",
    "issues": [
      {
        "type": "N+1 query",
        "description": "Lines 94, 145: check_doctor_availability() and check_patient_availability() load all appointments into memory and iterate in Python instead of using database overlap detection. Causes full table scan + O(N) memory usage.",
        "severity": "high",
        "lines": [94, 145],
        "impact": "Performance bottleneck when checking availability with 100+ appointments"
      }
    ]
  },
  {
    "file": "app/routers/messages.py",
    "issues": [
      {
        "type": "N+1 query",
        "description": "Lines 97-101: Iterating over messages and calling serialize_message() for each. If serialize_message() accesses uneager-loaded relationships, triggers N additional queries.",
        "severity": "medium",
        "lines": [97, 101],
        "impact": "O(N) database queries during message list serialization"
      },
      {
        "type": "missing rate limiting",
        "description": "Public message sharing endpoints lack adequate rate limiting. Consider stricter limits on message operations with file attachments.",
        "severity": "medium",
        "lines": [18, 63, 134],
        "impact": "Potential DoS vulnerability on message endpoints"
      }
    ]
  },
  {
    "file": "app/services/recommendation_service.py",
    "issues": [
      {
        "type": "N+1 query",
        "description": "Lines 78-104: get_patient_care_recommendations() loads all prescriptions and iterates in Python to check expiry dates. Should use SQL date calculations instead.",
        "severity": "high",
        "lines": [98, 100],
        "impact": "Performance degradation with large prescription lists (100+ prescriptions)"
      },
      {
        "type": "inefficient query pattern",
        "description": "Line 208-230: get_appointment_slot_recommendations() extracts hours from all appointments and builds set in Python. Should use SQL aggregation.",
        "severity": "medium",
        "lines": [211, 214],
        "impact": "Inefficient memory usage and O(N) iteration for availability calculation"
      }
    ]
  },
  {
    "file": "app/routers/recommendations.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "Lines 65, 123, 174, 216: Catching bare Exception and exposing raw error messages in HTTPException detail. Leaks internal implementation details and may expose PHI.",
        "severity": "high",
        "lines": [65, 123, 174, 216],
        "impact": "Security vulnerability: information disclosure; debugging difficulty"
      },
      {
        "type": "missing error handler",
        "description": "No specific handlers for PatientNotFoundError, InvalidDateFormat, or business logic exceptions. All map to generic 500 error.",
        "severity": "medium",
        "lines": [65, 123, 174, 216],
        "impact": "Poor HTTP status codes and error responses"
      }
    ]
  },
  {
    "file": "app/routers/shares.py",
    "issues": [
      {
        "type": "security",
        "description": "Line 84: /shares/access endpoint is public (no auth) with 20/hour rate limit. Insufficient for brute force protection on share tokens. Needs per-IP limiting and CAPTCHA.",
        "severity": "high",
        "lines": [84],
        "impact": "Vulnerability to token enumeration attacks; 20 attempts/hour insufficient"
      },
      {
        "type": "missing error handler",
        "description": "No specific audit logging for failed share access attempts (invalid token, invalid PIN, expired).",
        "severity": "low",
        "lines": [120, 133],
        "impact": "Cannot detect brute force or suspicious access patterns"
      }
    ]
  },
  {
    "file": "app/routers/batch.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "Lines 98, 204, 281: Generic Exception handlers return raw error messages. No distinction between validation, database, and runtime errors.",
        "severity": "high",
        "lines": [98, 204, 281],
        "impact": "Information disclosure; unclear error responses"
      },
      {
        "type": "security",
        "description": "Lines 120-135: Batch update accepts arbitrary update dictionaries without field whitelisting. Could allow injecting unauthorized fields (e.g., tenant_id, role).",
        "severity": "high",
        "lines": [120, 135],
        "impact": "Potential privilege escalation or data corruption"
      },
      {
        "type": "missing validation",
        "description": "No validation that patient/doctor exists before database insert. No check for duplicate active prescriptions.",
        "severity": "medium",
        "lines": [45, 130],
        "impact": "Foreign key violation errors instead of 404s"
      },
      {
        "type": "missing error handler",
        "description": "IntegrityError from duplicate unique constraints not caught. Returns generic 400 instead of proper conflict response.",
        "severity": "medium",
        "lines": [98],
        "impact": "Poor error responses on constraint violations"
      }
    ]
  },
  {
    "file": "app/routers/prescriptions.py",
    "issues": [
      {
        "type": "missing validation",
        "description": "Line 57: Direct creation without checking patient/doctor existence or validating dosage, duration, or frequency. No duplicate active prescription check.",
        "severity": "medium",
        "lines": [57],
        "impact": "Allows creation of prescriptions with non-existent patients/doctors; FK constraint violations"
      },
      {
        "type": "error handling gap",
        "description": "Lines 86, 108, 415: Best-effort exception handlers for event publishing lack specificity. No logging of failures.",
        "severity": "low",
        "lines": [86, 108, 415],
        "impact": "Silent failures in event publishing; difficult to debug"
      },
      {
        "type": "missing rate limiting",
        "description": "List endpoint has 60/minute but no pagination limit enforcement. Client can request limit=999999 to load entire table.",
        "severity": "low",
        "lines": [110],
        "impact": "Potential DoS via large pagination requests"
      }
    ]
  },
  {
    "file": "app/routers/patients.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "Lines 947, 979: Bare except Exception blocks swallow errors without logging. Silent failures on critical operations.",
        "severity": "medium",
        "lines": [947, 979],
        "impact": "Debugging difficulty; lost error context"
      },
      {
        "type": "missing error handler",
        "description": "No specific handler for DuplicateResourceError -> 409 Conflict. No handler for IntegrityError.",
        "severity": "medium",
        "lines": [102, 300],
        "impact": "Generic 400 instead of proper HTTP semantics"
      },
      {
        "type": "logging gap",
        "description": "File upload and batch operations don't log operation details (file size, count, parameters).",
        "severity": "low",
        "lines": [850, 900],
        "impact": "Limited debugging information for operations"
      }
    ]
  },
  {
    "file": "app/routers/documents.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "File upload endpoint lacks comprehensive error handling. No 413 Payload Too Large, 507 Insufficient Storage, or proper I/O error handling.",
        "severity": "medium",
        "lines": [85, 120],
        "impact": "Generic errors for disk-related failures"
      },
      {
        "type": "missing validation",
        "description": "No pre-upload validation of patient access/existence. File size validation happens in service, not router.",
        "severity": "medium",
        "lines": [75],
        "impact": "Potential access control bypass; late validation"
      },
      {
        "type": "missing error handler",
        "description": "No handler for malformed JSON tags parameter. TagDecodeError will return generic error.",
        "severity": "low",
        "lines": [60],
        "impact": "Unclear error messages for bad tag format"
      }
    ]
  },
  {
    "file": "app/routers/fhir.py",
    "issues": [
      {
        "type": "security",
        "description": "Lines 133-154: FHIR search parameters (name, family, given) use ILIKE without proper sanitization. While SQLAlchemy parameterizes, the pattern construction is vulnerable.",
        "severity": "medium",
        "lines": [140, 145, 150],
        "impact": "Potential SQL injection through ILIKE wildcard patterns"
      },
      {
        "type": "missing validation",
        "description": "Date parameter (birthdate) accepted as string without format validation. ISO format assumed.",
        "severity": "low",
        "lines": [153],
        "impact": "Poor error messages for malformed dates"
      }
    ]
  },
  {
    "file": "app/services/share_service.py",
    "issues": [
      {
        "type": "cache invalidation issue",
        "description": "Lines 152-170: validate_and_access_share() updates access_count but doesn't invalidate cache. Subsequent requests return stale data.",
        "severity": "medium",
        "lines": [168, 170],
        "impact": "Stale cache data for share access counts"
      },
      {
        "type": "missing logging",
        "description": "No audit logging for failed share access attempts (invalid token, invalid PIN, expired).",
        "severity": "low",
        "lines": [120, 133],
        "impact": "Cannot detect attack patterns"
      }
    ]
  },
  {
    "file": "app/services/document_service.py",
    "issues": [
      {
        "type": "missing validation",
        "description": "Lines 120-140: File size, MIME type, and filename validated but no duplicate detection or checksum collision handling.",
        "severity": "low",
        "lines": [125, 130],
        "impact": "Potential duplicate file storage; no deduplication"
      }
    ]
  },
  {
    "file": "app/routers/appointments.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "Line 70: Bare except Exception clause in get_appointment(). No logging of underlying error.",
        "severity": "medium",
        "lines": [70],
        "impact": "Silent exception swallowing; debugging difficulty"
      },
      {
        "type": "missing error handler",
        "description": "Lines 264, 287, 543, 619: Best-effort exception handlers for event publishing lack specific error handling and logging.",
        "severity": "low",
        "lines": [264, 287, 543, 619],
        "impact": "Silent failures in subscription events"
      },
      {
        "type": "missing validation",
        "description": "No validation that patient/doctor exists before appointment creation. No duplicate appointment check.",
        "severity": "medium",
        "lines": [95],
        "impact": "FK constraint violations instead of 404s"
      }
    ]
  },
  {
    "file": "app/routers/auth.py",
    "issues": [
      {
        "type": "error handling gap",
        "description": "No specific handler for Tenant validation errors. No rate limiting on registration endpoint is mentioned.",
        "severity": "medium",
        "lines": [59],
        "impact": "Generic error responses; 5/minute registration rate limit may be insufficient"
      },
      {
        "type": "missing validation",
        "description": "No password complexity validation in registration. No check for minimum password requirements.",
        "severity": "low",
        "lines": [46],
        "impact": "Weak passwords possible"
      }
    ]
  },
  {
    "file": "app/routers/users.py",
    "issues": [
      {
        "type": "missing error handler",
        "description": "No specific handler for non-existent users. Returns 404 but no distinct logging from other 404 scenarios.",
        "severity": "low",
        "lines": [52, 67],
        "impact": "Limited debugging information"
      }
    ]
  },
  {
    "file": "app/models/patient.py",
    "issues": [
      {
        "type": "missing eager loading option",
        "description": "No default eager loading strategy defined. Relationships (appointments, prescriptions, documents) will be lazy-loaded by default.",
        "severity": "medium",
        "lines": [70, 71, 72],
        "impact": "N+1 queries when accessing relationships without explicit joinedload/selectinload"
      }
    ]
  },
  {
    "file": "app/models/appointment.py",
    "issues": [
      {
        "type": "missing eager loading option",
        "description": "No default eager loading. Relationships (patient, doctor) lazy-loaded by default.",
        "severity": "low",
        "lines": [45, 46],
        "impact": "N+1 queries when accessing related objects"
      }
    ]
  },
  {
    "file": "app/models/message.py",
    "issues": [
      {
        "type": "missing eager loading option",
        "description": "No default eager loading. sender/receiver relationships lazy-loaded by default.",
        "severity": "medium",
        "lines": [59, 60],
        "impact": "N+1 queries when serializing message lists"
      }
    ]
  },
  {
    "file": "app/core/dependencies.py",
    "issues": [
      {
        "type": "missing rate limiting",
        "description": "get_current_user() dependency has no rate limiting applied to authentication checks. Could be exploited for token enumeration.",
        "severity": "low",
        "lines": [15, 25],
        "impact": "No protection against brute force on JWT validation"
      }
    ]
  },
  {
    "file": "app/services/patient_service.py",
    "issues": [
      {
        "type": "missing eager loading",
        "description": "Lines 81-87: list_patients() uses selectinload() which is good. However, list_patients_paginated() should also verify eager loading is applied for consistency.",
        "severity": "low",
        "lines": [155, 162],
        "impact": "Potential N+1 when accessing patient collections"
      }
    ]
  }
]
